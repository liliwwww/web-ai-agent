
# 定时任务管理系统需求文档


## 1. 引言
### 1.1 项目背景
用户需要一个基于Python的定时任务管理系统，支持任务的列表、创建、修改、删除、立即执行及定时触发，同时实现任务信息的持久化存储，并提供控制台和Web界面进行任务管理。该系统需满足Windows环境下的稳定运行，确保定时任务按计划执行。


## 2. 功能需求
### 2.1 核心功能
#### 2.1.1 任务管理
- **任务创建**  
  - 支持通过控制台或Web界面添加定时任务，指定任务ID、定时规则（日期触发器（date），间隔触发器（interval），Cron 触发器（cron），空闲触发器）、任务类型（send_email, send_sms, send_sql, query_log，auto_test等）及任务参数（因为任务不同，需要的参数也不相同，所以任务参数使用json格式。示例：send_email定义了三个参数 `{to="xxx", title="xxxxx", body="32232"}`）。

  
- **任务修改**  
  - 支持修改任务的定时规则和执行参数，修改后自动更新调度计划。任务ID和任务类型不能修改

- **任务删除**  
  - 支持通过任务ID删除任务，同时清除持久化存储中的任务信息。

- **任务立即执行**  
  - 支持手动触发任务执行，无需等待定时规则。

- **任务列表查询**  
  - 支持查看所有任务的详细信息，包括任务ID、任务类型、定时规则、执行参数、是否执行、执行次数，最后一次执行时间等。

- **任务执行列表查询**  
  - 提供执行日志查询界面，显示日志表中的所有信息。其中，查询条件包括任务类型， 执行时间范围（晚于开始时间，早于截至时间）。
  - 如果查询记录大于40条，提供翻页操作


#### 2.1.2 定时规则
- 在 `APScheduler` 里，提供了四种不同类型的定时器（触发器），每种都适用于不同的任务调度场景，下面为你详细介绍：

#### 1. 日期触发器（`date`）
- **适用场景**：适用于在特定的日期和时间执行一次任务的场景，像一次性的提醒任务、特定时刻的数据备份等。
- **示例代码**：

def job_function():
    print("任务执行！")

scheduler = BackgroundScheduler()
# 指定2025年12月10日早上8点执行任务
scheduler.add_job(job_function, 'date', run_date='2025-12-10 08:00:00')
scheduler.start()

- **参数说明**：
    - `run_date`：指定任务执行的具体日期和时间，可以是字符串（如 `'2025-12-10 08:00:00'`）、`datetime` 对象或者 `date` 对象。

#### 2. 间隔触发器（`interval`）
- **适用场景**：适用于按照固定的时间间隔重复执行任务的场景，例如定时的数据采集、周期性的系统监控等。
- **示例代码**：

scheduler = BackgroundScheduler()
# 每隔5分钟执行一次任务
scheduler.add_job(job_function, 'interval', minutes=5)
scheduler.start()

- **参数说明**：
    - `weeks`：间隔的周数。
    - `days`：间隔的天数。
    - `hours`：间隔的小时数。
    - `minutes`：间隔的分钟数。
    - `seconds`：间隔的秒数。
    - `start_date`：任务开始执行的日期和时间，默认是当前时间。
    - `end_date`：任务停止执行的日期和时间。

#### 3. Cron触发器（`cron`）
- **适用场景**：适用于按照复杂的时间规则执行任务的场景，类似Linux系统中的 `cron` 服务，可用于按天、周、月、年等周期执行任务，如每天凌晨的数据清理、每月初的报表生成等。
- **示例代码**：

scheduler = BackgroundScheduler()
# 每天早上8点执行任务
scheduler.add_job(job_function, 'cron', hour=8)
scheduler.start()

- **参数说明**：
    - `year`：年份，取值范围是 1970 - 2099。
    - `month`：月份，取值范围是 1 - 12。
    - `day`：日期，取值范围是 1 - 31。
    - `week`：周数，取值范围是 1 - 53。
    - `day_of_week`：星期几，取值范围是 0 - 6（0 表示星期日）或者使用缩写（如 `mon`、`tue` 等）。
    - `hour`：小时，取值范围是 0 - 23。
    - `minute`：分钟，取值范围是 0 - 59。
    - `second`：秒，取值范围是 0 - 59。
    - `start_date`：任务开始执行的日期和时间。
    - `end_date`：任务停止执行的日期和时间。

#### 4. 空闲触发器（`idle`）
- **适用场景**：适用于在系统处于空闲状态时执行任务的场景，例如在系统CPU使用率较低时进行数据处理等。
- **示例代码**：
# 在系统空闲时执行任务

try:
    while True:
        time.sleep(1)
except (KeyboardInterrupt, SystemExit):
    scheduler.shutdown()

- **参数说明**：
    - `idle_duration`：指定系统空闲的持续时间，单位为秒，默认是 60 秒。

综上所述，`APScheduler` 的这四种触发器基本能满足各种不同的任务调度需求，你可以依据具体的业务场景来选择合适的触发器。 


#### 2.1.3 任务持久化
- **存储方式**  
  - 使用SQLite数据库（`task.db`）存储任务调度信息，确保程序重启后任务不丢失。  
  - 使用Pickle序列化技术（`tasks.pkl`）存储任务参数和状态。

#### 2.1.4 执行函数示例
- **发送邮件任务**  
  - 函数名称：`send_email`  
  - 入参：`to`（收件人邮箱）、`title`（邮件主题）、`body`（邮件内容）  
  - 功能：通过SMTP协议发送邮件，支持错误重试和日志记录。


## 2.2 辅助功能
### 2.2.1 日志记录
- 记录任务的创建、修改、删除、执行等操作日志。  
- 记录任务执行结果（成功/失败）及异常信息，存储至日志文件`scheduler.log`。

### 2.2.2 异常处理
- 处理任务执行过程中的网络异常（如邮件发送失败）、参数错误、文件读写错误等。  
- 支持任务重试机制（如邮件发送失败后重试3次）。

### 2.2.3 任务执行日志记录
  - 任务执行后，记录日志，日志保存在sqllite数据表中。
  - 日志表保存的信息包括:任务ID、任务类型、定时规则、执行参数、执行结果（成功/失败）、执行耗时，执行时间(到ms级别)


## 3. 非功能需求
### 3.1 环境要求
- **操作系统**：Windows环境（支持控制台运行，无需注册系统服务）。  
- **依赖库**：Python 3.7+、APScheduler、Flask（Web界面）、SQLAlchemy（持久化）、pywin32（可选，如需注册服务）。

### 3.2 性能要求
- **任务调度精度**：定时任务执行时间误差不超过1分钟。  
- **并发支持**：支持至少10个任务同时运行，CPU和内存占用稳定。

### 3.3 易用性
- **Web界面**：提供可视化操作界面，支持任务的增删改查及状态查看。  
- **控制台交互**：支持通过命令行初始化任务、查看日志。
- **前后端解耦**：要求后台和html分离


## 4. 界面需求
### 4.1 Web界面（基于Flask）
#### 4.1.1 任务列表页
- 展示所有任务的任务ID、任务类型、定时规则、执行参数、是否执行、执行次数，最后一次执行时间等、操作按钮（执行、修改、删除）。  
- 支持分页和搜索（后续扩展）。

#### 4.1.2 添加/修改任务页
- 输入框：任务ID、  定时规则（根据定时规则，四种不同类型的定时器，并提供定时器参数），任务类型（下拉框）、执行参数（textarea）
- 有效性校验：用户提交前，需要验证textarea中的文本是否符合json格式要求。
- 提交按钮：完成任务创建或修改。

### 4.2 控制台界面
- 支持通过`main`方法启动程序，持续运行并监听任务调度。  
- 后台程序需要对任务的列表，添加，查询，修改，删除，日志查询能操作进行API封装
- 生成针对后台主要方法得测试用例。
- 捕获`Ctrl+C`中断信号，优雅停止调度器


## 5. 接口需求
### 5.1 外部接口（待扩展）
- **邮件服务接口**：支持配置不同的SMTP服务器（如网易、腾讯邮箱）。  
- **第三方API接口**：未来可扩展支持HTTP接口调用任务（如调用外部数据接口）。

### 5.2 内部接口
- **任务调度接口**：通过APScheduler提供的API实现任务的添加、修改、删除（`add_job`、`reschedule_job`、`remove_job`）。
- WEB页面程序调用后台封装的程序。

## 6. 测试需求
### 6.1 功能测试
- **任务创建**：验证任务是否正确添加到调度器和持久化存储。  
- **定时触发**：验证任务是否在指定时间执行（如设置1分钟后执行，观察日志）。  
- **立即执行**：验证手动触发任务是否成功执行。  
- **持久化**：重启程序后，验证任务是否从`task.db`和`tasks.pkl`中正确加载。

### 6.2 异常测试
- **参数错误**：验证输入非法Cron表达式（如`25:60`）时是否报错。  
- **文件权限**：验证无写入权限时是否正确处理持久化文件。


### 7.代码生成需求
在使用 pickle 保存 tasks 字典时，其中包含了 send_email 函数的引用。在重新加载程序时，pickle 尝试从 __main__ 模块中查找 send_email 函数，但由于程序的启动和加载过程，pickle 无法正确解析这个引用。可以通过将 send_email 函数移到一个单独的模块中，避免 pickle 在反序列化时出现问题。


## 7. 部署与运行
### 7.1 部署步骤
1. 安装依赖：  
   ```bash
   pip install apscheduler flask sqlalchemy pywin32
   ```
2. 配置文件路径（绝对路径）：  
   - SQLite数据库：`C:\Users\wdp\project\py-schedual\src\utils\schedule\task_up.db`  
   - Pickle文件：`C:\Users\wdp\project\py-schedual\src\utils\schedule\tasks_up.pkl`  
3. 启动程序：  
   - 控制台模式(后台)：`python task_management_up.py`  
   - Web模式（可选）：`python app_up.py`（需配套Flask界面代码）。

### 7.2 维护
- **日志查看**：定期检查`scheduler.log`，排查任务执行异常。  
- **数据库备份**：定期备份`task.db`，防止数据丢失。


## 8. 附录
### 8.1 术语表
- **Cron表达式**：用于定义定时任务执行时间的表达式，本系统简化为`HH:MM`格式。  
- **持久化**：将任务信息存储到数据库或文件，确保程序重启后数据不丢失。  
- **守护进程**：在后台持续运行的进程，本系统通过控制台循环实现类似功能。

### 8.2 参考资料
- APScheduler官方文档：https://apscheduler.readthedocs.io  
- Flask Web框架：https://flask.palletsprojects.com  


**版本控制**：  
- V1.0（当前版本）：实现基础任务管理、持久化、控制台运行。  
- V1.1（规划）：支持复杂Cron表达式、Web界面优化、多用户权限管理。


启动
C:\Users\wdp\project\web-ai-agent\src>python c:/Users/wdp/project/web-ai-agent/src/utils/schedule/app.py




再补充一下需求， 任务类型除了send_email之外，还需要send_sms， send_cmd, send_SqL 等各种操作。在WEB界面中，在添加界面中， 指定任务ID，任务类型，触发时间，以及参数。因为不同的任务参数不同，提供textarea文本框，允许用户输入json格式的参数。 任务类型采用下拉框的方式， 列表中显示 任务ID， 触发时间， 任务类型和 任务参数。 。